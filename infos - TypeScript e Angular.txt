# Arquivo de informações do MEAT-APP Refatorado de Template Forms para Reactive Forms
Este repositório continua o curso de Angular: App Angular (MEAT App) do Curso Construindo Aplicações Web Com o Novo Angular (4, 5 e 6)
Versão do repositório com Template Forms: https://github.com/dantovsky/meat-app
Neste repositório, as novas modificações são a partir da aula 71.

19:43 07/01/2019

------------------------------------------------------------------
Arquivos importantes
------------------------------------------------------------------
tsconfig.json (arquivo que vai conter as configurações básicas do compilado)
packsge.json (criado após "npm ini -f", onde tem as dependências e outras configurações)
app.ts (arquivos de script)

------------------------------------------------------------------
Auto compilação dos arquivos ts
------------------------------------------------------------------
Tem duas maneiras:
1. Uma no tsconfig.json:
{
   "compileOnSave": true,
   "compilerOptions": {
       "outDir" : "dist"
   }
}
O outDir manda o JS para o diretório listado. Se quiser deixar na mesma pasta, pode remover esse atributo, mas deixo explícito aqui porque usamos mais na frente de qualquer forma.
2. Você pode deixar o compilador do ts executando em background. Essa opção é livre de editor e funciona para qualquer um. Abre uma nova aba ou instância do terminal, digita:
tsc -w (precisa instalar o compilador TypeScript com "np install typescript -g"
E deixa em background.

------------------------------------------------------------------
MODULO ::  O que é um módulo? >> Organiza o conteúdo
------------------------------------------------------------------
Uma unidade que contém classes, interfaces, funções e variáveis
com o objetivo de deixar o conteúdo de uma app isolado do restante da app.

No brwoser é necessário usar carregadores de módulos como:
- requireJS
- systemJS

Na aula 13 organizamos tudo o que foi feito para trás, ficando com os arquivos:
- base-ships.ts
- starfighters.ts

------------------------------------------------------------------
NAMESPACE (antigos módulos internos)
------------------------------------------------------------------
Outra maneira de organizar o code, e evita colisão de nomes.
Ex:

ARQUIVO: utilities.ts

namespace Utilities {
  export class ShipCleaner {...}
  function calcDistance(...)  {...}
}

ARQUIVO: other.ts
/// <reference path = "Utilities.ts" />

------------------------------------------------------------------
O que é Definição de Tipo?
------------------------------------------------------------------
...é apenas a definição de tipo daquela biblioteca, não é a implementação.
Possuem a extenção *.d.ts

Como obter as definições de tipo?
- npm registry
- Definitely Typed (Githup >> instalação manual)

Através do npm:

npm init // responder as perguntas, pode fazer "npm init -f" para forçar as configs padrões
name: (typescript)
version (1.0.0)

npm install --save lodash@4.14 // --save indica que a dependencia vai ser importante, e significa que vai usar essa dependencia tanto em desenvolvimento quanto em runtime
lodash@4.14

npm install -save-dev @types/lodash@4.14 // deve instalar também as definições de tipos do lodash
@types/lodash@4.14.51

O resultado criará um arquivo packages.json com as configs básicas da app e também as suas dependências

Devido a um bug no Atom, é necessário informar no arquivo tsconfig.json
"typeRoots": [
"nome_modules/@types"
]

------------------------------------------------------------------
Criar uma app (09/01/2019)
------------------------------------------------------------------
ng new nome-app --prefix=jad // --prefix é o que vai ser utilizado na frente de cada componente que for criado

------------------------------------------------------------------
Bootstrap (inicialização) do Angular com Webpack
------------------------------------------------------------------
O app.module.ts carrega o app.component.ts que carrega o app.component.html
No app.component é onde se define os componentes da app inicial, o seletor (tag) e o templateUrl

------------------------------------------------------------------
Componentes :: São elementos personalizados
------------------------------------------------------------------
Componentes são pequenas partes independentes reusáveis
>> Em Angular, são classes que tem um determinado ciclo de vida e que possui:
- um template para definir uma aparência
- e um selector (tag) :: para ser usada por outras partes da app

COMO DEFINIR UM COMPONENT ::

Um componente é uma classe que segue a sintaxe do ECMAScript 2015 + as features do TypeScript.
Sempre que declaramos a classe, a marcamos com a palavra "export", para que ela possa ser referenciada posteriormente
em outros arquivos de configurações exigidos pelo framework. Portanto quando marcamos com "export" esse arquivo passa a ser um módulo ECMAScript 2015.

Há mais coisas que precisamos informar ao Angular:
- qual o nome da TAG que queremos usar com esse componente?
  > para isso usamos o decorator @Component, e nele precisamos unformar duas coisas:
    - selector (TAG)
    - qual o template que o componente vai ter

    // ------------------------ COMPONENT (exemplo)----------------------

    import { Component } from '@angular/core';

    @Component({    // ------------------------------------------------------| DECORATOR
      selector: 'app-first',    // ------------------------------------------| SELECTOR (TAG)
      templateUrl: './myFirst.component.html'     // ------------------------| TEMPLATE QUE O COMPONENTE VAI TER
    })

    export class MyFirstComponent {
      constructor() {}
    }

Notas: existem duas formas de declarar um template:
- num arquivo externo através do atributo "templateUrl" (relativa, absoluta ou um URL HTTP)
- declarar o template direto dentro arquivo, mas usando o atributo "template" ao invés de "templateUrl". Forma recomendada apenas para template pequeno e simples.

    Exemplo ::
    template: '<h1>My first component</h1>'

    Exemplo utilizando MULTIPLAS LINHAS (sintaxe de template strings, do ECMAScript 2015) >> Acente crase (back tick)
    template: `<h1>
                  My first component
              </h1>`

    // ------------------------ TEMPLATE INTERPOLATION ----------------------
    // Os templates podem ter expressões que resolvem as propriedades do componente (template interpolation)

    @Component({
      selector: 'app-first',
      template: `<h1> {{title}} </h1>
                 <p>Welcome, {{user.name}}`
    })

    export class MyFirstComponent {
      title: string = 'My Star Wars Component'
      user = {name: 'Luke Skywalker'}
    }


    // ------------------------ COMPONENT (app.component.ts)----------------------

    import { Component } from '@angular/core';

    @Component({
      selector: 'jad-root',
      templateUrl: './app.component.html'
    })
    export class AppComponent {
      title = 'jedi-academy';
    }

Uma vez criado o componente, é necessário informar em qual módulo Angular o componente vai estar:
(não confundir módulos do Angular com módulos do ECMAScript 2015)
O módulo Angular é responsável por saber quais componentes, serviços, pipes e diretivas fazem parte da aplicação.
Cada um desses precisam estar em um módulo.
Se a declaração for feita num módulo raiz, toda a app tem acesso a aquele componente.

@NgModule({
  declarations: [MyFirstComponent]
})
export class AppModule {}

CRIAÇÃO DE COMPONENTE NO CONSOLE
ng generate component header --spec=false     // spcec é um param para gerar os arquivos de teste ou não

// forma reduzida deste comando:
ng g c header --spec=false

------------------------------------------------------------------
Property Binding
------------------------------------------------------------------
É quando deseja linkar o valor de uma propriedade de um elemento a uma expressão Angular, que pode avaliar para uma propriedade
de um componente, método ou até uma expressão mais elaborada.

Sintaxe ::

feita com [] "colchetes" ao redor da propriedade do elemento que se deseja atribuir o valor e pode ser aplicada a qualquer propriedade
de um elemento do DOM.

Exemplo ::

// no componente
user = {name: 'Luke Skywalker'}

<!-- no template do componente -->
<input type="text" [value]="user.name">

Sempre que o valor de name de user mudar, o valor de input também vai mudar,
mostrando que eles estão "ligados" >> Por isso é chamado de PROPERTY BINDING

Nesse caso, como a atualização é sempre em um sentido, se chama ONE-WAY BINDING
O one-way binding é sempre do COMPONENT => TEMPLATE

Exemplo ::

// in component
user = {name: 'Luke Skywalker'
        isJedi: true}

<!-- in template -->
<input type="text" [value]="user.name">
<div [hidden]="!user.isJedi">
    location of the jedi temple
</div>

É possível também usar certas expressões, como por exemplo [class.light] e associá-la a expressões booleanas,
se a variável for verdadeira, o Angular vai adicionar a classe "light" ao elemento final na renderização

Exemplo ::
<div [class.light]="user.isJedi"></div>

... renderizado ficará assim:
<div class="light"></div>

------------------------------------------------------------------
Passando Valores a um Componente
------------------------------------------------------------------
Como passar dados para um componente?
As propriedades que adicionamos aos componentes são públicas, mas precisamos avisar ao Angular quais dessas propriedades
podem receber dados dos seus componentes parents através de PROPERTY BINDING.

- ou lista-se um atributo que quer expor na lista de inputs do decorator @Component,
- ou marca um atributo com outro decorator, chamado @Input

Exemplo ::
Caso queira que o attr title deste componente possa ser alterado pelo seu component parent,
precisamos importar o decorator Input e adicioná-lo ao lado do attr

import { Component, Input } from '@angular/core'

@Component({
  selector: 'mt-header',
  template: '<h1>{{title}}</h1>'
})
export class HeaderComponent {
  @Input() title: string
}

- - -

<!-- usando o header em outro componente -->
<mt-header title="Minha App"></mt-header>

- - -

<!-- DOM em runtime -->
<mt-header title="Minha App">
    <h1>Minha App</h1> -----------------------------| CONTEÚDO RENDERIZADO
</mt-header>

- - - Pode também passar o valor por template interpolation ou property binding

<!-- template interpolation -->
<mt-header title="{{isJedi ? 'Jedi' : 'Sith'}}"></mt-header>

<!-- property binding -->
<mt-header [title]=isJedi ? 'Jedi' : 'Sith'"></mt-header>

- - - Uma outra possibilidade é expor o attr com um outro nome. Por padrão, o nome do attr é que é exporto

import { Component, Input } from '@angular/core'

@Component({
  selector: 'mt-header',
  template: '<h1>{{title}}</h1>'
})
export class HeaderComponent {
  @Input('value') title: string <--------------------- fizemos uma substituição para o nome "value"
}

- - -

<!-- usando o nome definido em @Input -->
<mt-header value="Título"></mt-header>

NOTA :: sempre que se quiser parra um valor que não seja string, precisa usar a  sintaxe de PROPERTY BINDING.

O hidden deve ser usado com bastante cautela e temos que saber que o hiiden controla a visibilidade do elemento por CSS.
Então o estilo global, CSS em algum outro lugar, pode estar influenciando na visibilidade de um componente.

Mais tarde, isto será melhorado com o uso de "diretivas".

------------------------------------------------------------------
DIRETIVAS :: São componentes com templates
------------------------------------------------------------------
Uma diretiva comum e simples serve para adicionar comportamento a um elemento do DOM, mas não tem o template de um componente.

Na realidade, existem 2 tipos de diretivas no Angular:
- COMPONENTES : mais comuns
- ESTRUTURAIS : mudam o template e a estrutura do DOM (Ex: ng-for e ng-if)
- ATRIBUTOS : onde associa um atributo a um elemento do DOM e um determinado comportamento é aplicado a esse elemento

- - - NG IF - - -
<!-- A diretiva ngIf é uma opção bem mais segura de usar que a propriedade HIDDEN, por que a prop hidden depende de estilos CSS, e esse estilo pode estar sendo sobrescrito em algum lugar da app.  -->

<!-- ng if -->
<input type="text" [value]="user.name">
<div *ngIf="user.isJedi">
  location of the jedi temple
</div>

- - -

<!-- ng if (versão não abreviada) -->
<input type="text" [value]="user.name">
<template [ngIf]="user.isJedi">
  <div>
    location of the jedi temple
  </div>
</template>

- - - ng if (if else) - - -

<div class="navbar-custom-menu">
  <ul class="nav navbar-nav">
    <li class="user user-menu">
      <!-- Diretiva if-else que foi add no Angular 4.2 -->
      <span *ngIf="isLoggedIn(); else notLoggedIn">
        Olá, {{user.name}} | <a (click)="logout()">Sair</a>
      </span>
      <ng-template #notLoggedIn>
        <a (click)="login()">Entrar</a>
      </ng-template>
    </li>
  </ul>
</div>

- - - NG FOR - - -

ngFor vai repetir o conteúdo de um elemento para cada item de uma coleção de objetos (repete o template de cada elemento)
<!-- ng for -->
<ul>
	<li *ngFor="let user of users">{{user.name}}</li>
</ul>

Podemos também declarar uma variável para saber cada elemento da lista (começa com index = 0)
<!-- ng for -->
<ul>
	<li *ngFor="let user of users; let i=index">
		{{user.name}}
	</li>
</ul>

- - - NG SWITCH - - -

O ngSwitch e o ngSwitchCase renderiza o conteúdo equivalente, o ngSwitchDefault mostra o conteúdo se nenhum dos conteúdos for verdadeiro
<div [ngSwitch]="profile">
	<p *ngSwitchCase="root">You can read & write</p>
	<p *ngSwitchCase="user">You can read</p>
	<p *ngSwitchDefault>go back, please!</p>
</div>

------------------------------------------------------------------
Usando Operador de Navegação Segura
------------------------------------------------------------------
Para evitar erros na consola JS (ex: "Cannot read property 'isJedi' of undefined"), podemos utilizar a "?" nas variáveis ou utilziar o *ngIf chamando apenas o conteúdo existente.

- - - Uso de ?

<div>
  Student: {{student?.name}}
  <div *ngIf="student?.isJedi">
    Jedi Temple: {{student?.temple}}
  </div>
</div>

- - - Uso de ngIf

<div *ngIf="student">
  Student: {{student?.name}}
  <div *ngIf="student?.isJedi">
    Jedi Temple: {{student?.temple}}
  </div>
</div>

<p *ngIf="!student">
  Sem dados para exibir!
</p>

------------------------------------------------------------------
COMPONENTES E EVENTOS
------------------------------------------------------------------
Duas formas:
- como um componente responde a eventos internos que ocorre dentro do próprio template
- como um componente pode produzir eventos que podem ser consumidos por outros componentes interessados

SINTAXE DOS EVENTOS: - ()
usamos parenteses ao redor de um evento para linká-lo a um método de um componente, assim sempre que a ação ocorrer, o método é chamado.

- - - Exemplo

import { Component } from '@angular/core';

@Component({
  selector: 'mt-clickable',
  templateUrl: '<button (click)="clicked()">Click!</button>'
})

export class ClickableComponent {

	clicked(): void {
		console.log('Button clicked!')
	}
}

- - - Referência ao evento através do obj $event

<!-- no tempalte do componente -->
<button (click)="clicked($event)">Click me!</button>

      |
      |
      |
      V

 // na função
 clicked(event): void {
   console.log(`Button clicked: ${event}`)
 }

- - - No evento keydown podemos associar a tecla, separada por ponto:

<!-- no tempalte do componente -->
<input (keydown.space)="keyDown($event)">

      |
      |
      |
      V

 // na função
 keyDown(event): void {
   console.log(`Key down: ${event}`)
 }


 ------------------------------------------------------------------
 EVENTOS DE COMPONENTES
 ------------------------------------------------------------------
Um componente pode emitir um evento personalizado também.
Para isso usamos uma classe chamada EVENTEMITTER, que é um adapter para a biblioteca RXJS, e possui um método emit(),
que chamamos quando chegar o momento de emitir o evento.

Pegando o exemplo anterior, se quiser criar um evento personalizado, precisamos importar mais dois tipos (Output e EventEmitter).
@Output() emite o evento, a saída do componente. O tipo será EventEmitter e o nome do evento, por padrão, é o nome da propriedade.

import { Component, Output, EventEmitter } from '@angular/core';

@Component({
  selector: 'mt-clickable',
  templateUrl: '<button (click)="clicked()">Click!</button>'
})

export class ClickableComponent {

  @Output myEvent = new EventEmitter()

	clicked(): void {
		this.myEvent.emit()
	}
}

Usando o componente, podemos atribuir o método que será chamado quando o evento for emitido

<!-- no tempalte que usa o componente -->
<mt-clickable (myEvent)="willBeCalled()"></mt-clickable>

      |
      |
      |
      V

willBeCalled(): void {
  console.log('Event from clickable')
}

------------------------------------------------------------------
VARIÁVEIS DE TEMPLATES
------------------------------------------------------------------
Em um elemento, podemos usar uma sintaxe #nome-da-variavel.
Isso irá permitir:
- vai poder usar uma referência desse elemento dentro do template ou passar isso para um método. Com essa referência pode-se acessar atributos e métodos.

Exemplo: um textarea com uam variável #desription e um botão com uma função que ao clicar faz o focus para a textarea com a variável #description.

<div *ngIf="student?.isJedi">
  Jedi Temple: {{student?.temple}} <button type="button" name="button" (click)="description.focus()">Focus!</button>
  <br>
  <textarea name="name" #description></textarea>
</div>

------------------------------------------------------------------
ROTAS E NAVEGAÇÃO
------------------------------------------------------------------
No template de um componente, quando quisermos marcar uma área para ser trocada sempre quando um
novo componente entrar em cena, precisamos colocar o elemento "router-outlet".

<!-- no template do componente -->
<div>
	<mt-header></mt-header>           ------------------------------- FIXO
</div>
<div>
	<outer-outlet></outer-outlet>     ------------------------------- DINÂMICO
</div>

- - - Rotas são um array

- - - Precisa indicar que rotas serão usadas no módulo através da função:
      - forRoot(ROUTES) no módulo raiz, ou
      - forChild nos outros módulos

- - - Como os caminhos são acionados ::

<!-- no template de algum componente :: um caminho a ser acionado -->
<a routerLink="/restaurants">Restaurantes</a>

<!-- ou :: um conjunto de parametros -->
<a [routerLink]="['/restaurants']">Restaurantes</a>

------------------------------------------------------------------
INJEÇÃO DE DEPENDÊNCIA
------------------------------------------------------------------
É um padrão de projeto onde a pp deixa de instanciar seus objetos manualmente e passa a depender
do framework para obter os objetos que ela quer usar.

O framework gerencia a instanciação dos objs, bem como suas dependências e disponibiliza isso
para os componentes da app.

# Informando ao Angular o que será injetado
Pra deixar um serviço disponível pra ser injetado em componentes, é necessário declará-lo
na lista de providers de um componente ou módulo.

Se for no:
- COMPONENTE :: uma instancia do serviço fica disponível para o componente e seus filhos

@Component({ providers: [ MyFirstService ] })
export class MyFirstService {
  constructor(private firstService: MyFirstService) { }
}

- MÓDULO :: o serviço fica disponível para todos os componentes da app.
@Ngmodule({
  declarations: [...],
  providers: [ MyFirstService],
})
export class AppModule {}

------------------------------------------------------------------
SERVIÇOS
------------------------------------------------------------------
São classes comuns em Angular, que se pode usar para injetar em componentes e em outros serviços.
Serviços são geralmente usados em uma app para encapsular o acesso a API de backend.

Podem ser SINGLETONS.

São  os escopos que se pode usar para declarar um serviço:

- Módulo Angular -----------------| providers: []
  Fica disponível para ser injetado por todas as classes declarados nesse mesmo módulo (inclui componentes e outros serviços)

- Componente e seus filhos -----------------| providers: []
  O serviço vai ser intanciado e compartilhado apenas para o componente e seus componentes filhos

- Somente componente  -----------------| viewProviders: []
  Fica apenas disponível para o componente

# Serviços também podem solicitar injeção de outros serviços
Para isso deve usar o decorator @Injectable() ------------| apenas para receber injeções

import { Injectable } from '@angular/core'
import { Http } from '@angular/http'

@Injectable() // RECEBER INFECOES

export class MyService {

  constructor(private http: Http) {
  }

  list() {
    return this.http.get('/url')
  }
}

Exemplos de SERVIÇOS que o Angular disponibiliza:

- TITLE: serviço para obter e alterar o título de uma página.
  O componente pode requisitar a injeção e usar o método setTitle para substituir o título.
  Este serv existe porque não é possível usar expressões Angular na página HTML inteira, como o title fica
  no <head> e essa parte não faz parte o Bootstrap, criaram essa alternativa com o Serviço TITLE.

  import { Title } from '@angular/platform-browser'

  @Component({
    viewProviders: [Title]
  })
  export class MyPageComponent {

    constructor(title: Title) {
      title.setTitle(':: My Fancy Title ::')
    }
  }

- HTTP: encapsula acesso HTTP

- ROUTER: realiza navegação de forma programática

------------------------------------------------------------------
REACTIVE PROGRAMING (Iterator + Observer)
------------------------------------------------------------------
Você ouve um evento, e quando ele acontece, você é notificado e responde a ele.

Baseado no padrão chamado "observer" (fornecido pela biblioteca RXJS)
Um evento acontece, e os que estão interessados reagem a ele.

NO Angular, os métodos da API HTTP retornam Observable<RESPONSE>
GET, POST, PUT, DELETE HEAD, OPTIONS

------------------------------------------------------------------
Packages Instaladas no Projeto MEAT App
------------------------------------------------------------------
npm install -g json-server                --------| emular um API server

------------------------------------------------------------------
Parametrizando Rotas
------------------------------------------------------------------
2 formas de obter parâmetros:

- a partir de SNAPSHOT (fotografia dos params no momento em que a gente pedir)
(1) precisa injetar o objeto AcivatedRoute no contrutor do componente
(2) usar a funcao snapshot passando o id como params

export class MyComponent implements OnInit {

  constructor(private rout: ActivatedRoute) { } -------------------------| (1)

  ngOnInit() {
    const id = this.route.snapshot.params['id'] -------------------------| (2)
    this.myObj = // ...obter os dados baseado no id
  }
}

- SUBSCRIBE (se inscrevendo na rota e executando a mudança de params)

export class MyComponent implements OnInit {

  constructor(private rout: ActivatedRoute) { } -------------------------| (1)

  ngOnInit() {
    // O componente se inscreve para recever as notificações de mudança de parâmetros nas rotas
    this.route.params.subscribe(params => { -----------------------------| (2)
      const id = params['id']
      this.myObj = // ...obter os dados baseado no id
    })
  }
}

------------------------------------------------------------------
PIPES
------------------------------------------------------------------
Transformam dados para uma apresentação diferente
- string para uppercase ou lowercase
- formatar números
- formatar moedas
- formatar datas
- limitar o tamanho de um array
- formatar um conteúdo JSON

Exemplos:

# Pipe JSON
Ver uma  representação JSON de um objeto (exibe todas as propriedades de um obj)

<!-- in component -->
user = { name: 'Luke Skywalker', isJedi: true }

<!-- in template (JSON PIPE)-->
<div>{{user | json}}</div>

<!-- renderizado -->
<div> { name: 'Luke Skywalker', isJedi: true } </div>


# Pipe uppercase
<!-- in template -->
<div>{{user | uppercase}}</div>

# Pipe lowercase
<!-- in template -->
<div>{{user | lowercase}}</div>

# Pipe percent
<!-- in template -->
<div>{{0.5 | percent}}</div>

# Pipe date
<!-- in template -->
<div>{{birthday | date: 'dd/M/yyyy'}}</div>

# Pipe moeda
<!-- in template -->
<div>{{price | currency}}</div>

<!-- renderizado -->
<div>USD45.90</div>

//

<!-- in template (com 3 params opcionais:
1. string ISO da moeda a ser usada
2. indica se usa-se o símbolo ao invés da string ISO
3. indica o formato do número) -->
<div>{{price | currency: 'BRL': true}}</div>

<!-- renderizado -->
<div>R$45.90</div>

# Pipe slice :: limitar arays e strings
<!-- in template (limitado aos 4 primeiros caracteres da string)-->
<div>{{user.name | slice: 0:4}}</div>

<!-- renderizado -->
<div>Luke</div>

# Pipes combinados com outros pipes
<!-- in template -->
<div>{{['one', 'two'] | slice: 0:1 | json | uppercase}}</div>

<!-- renderizado -->
<div>["ONE"]</div>

------------------------------------------------------------------
# 54 Internacionalização :: Localiazando o currency para moeda BRL
------------------------------------------------------------------
Precisa adicionar nas dependêcias do projeto ::

Arquivo package.json
- "intl": "^1.2.5" => o pipe currency utiliza esse pacote

Arquivo polyfills.ts
Incluir a dependência do pacote "intl" e incluir o script necessário pela biblioteca do Angular para converter os números para o padrão PT
- import 'intl';
- import 'intl/locale-data/jsonp/pt-BR.js';

Agora precisa dizer ao Angular que queremos usar como localização o padrão pt-BR
faz-se isso no módulo raiz:
- LOCALE_ID ::
  import { NgModule, LOCALE_ID } from '@angular/core';
- na lista de providers precisamos trocar o valor da localização utilizando esse token ::
  providers: [RestaurantsService, ShoppingCartService, {provide: LOCALE_ID, useValue: 'pt-BR'}],

------------------------------------------------------------------
# 55 Template Forms
------------------------------------------------------------------
Forma declarativa de configurar formulários no template do componente.

# Config no app.module.ts ::
- import { FormsModule } from '@angular/forms'
- imports: [
  BrowserModule,
  HttpModule,
  FormsModule, ------------------------------| Add também no imports @ngModule
  RouterModule.forRoot(ROUTES)
],

Usamos a diretiva ngModel nos inputs que devem ser controlados pelo framework.

# DIRETIVA "ngForm" :: O Angular associa implicitamente a diretiva ngForm a uma tag <form>.
Com essa diretiva podemos determinar:
- validade do form
- valor
- outros status: dirty, pristine e touched

Com "template forms" é preciso usar a diretiva ngModel (o atributo name será obrigatório)

Form rastreia os campos com ngModel e passa a ficar ciente do valor do campo
<form>
	<input type="text" name="name" ngModel>
</form>
Neste exemplo:
- form valid se name valid
- form invalid se name invalid

# ONE-WAY BINDING associando o campo a uma propriedade de um componente:
<form>
	<input type="text" name="name" [ngModel]="username">
</form>
// -----------------------------------| Nesse caso, apenas quando o valor do componente mudar o valor é atualizado (o contrário não acontece)
@Component({...})
export class UserComponent {
  username: string = "Nome do usuário"
}

# TWO-WAY BINDING associando o campo a uma propriedade de um componente (nas duas vias de sentido):
<form>
	<input type="text" name="name" [(ngModel)]="username">
</form>
// -----------------------------------| Nesse caso, se o campo mudar, o valor da propriedade do componente também muda
@Component({...})
export class UserComponent {
  username: string = "Nome do usuário"
}

# ngForm permite acessar propriedades do formulário
Podemos obter uma ref a diretiva através de template variables e construir expressões que ajudam a controlar o acesso a certos componentes do form,
por exemplo: habilitar ou não um botão baseado da validade do próprio form.
<form #myForm="ngForm">
	<input type="text" name="name" ngModel>
	<input type="text" name="lastname" ngModel>
	<input type="text" name="address" ngModel>

	<button [disabled]="myForm.invalid"></button>
</form>

# Desabilitar a validação de forms do browser
Cada browser tem um estilo de validação diferente. Portanto criamos uma experiência comum com o Angular
<form novalidate>

# Debugger e ver valores do template forms ::
podemos analisar os dados com a exibição dos valores (utilizando a template variable):
{{form.valid}} {{form.value | json}}


------------------------------------------------------------------
# 58 Validação com Template Forms
------------------------------------------------------------------
A diretiva ngModel disponibiliza os seguintes estados que podem ser verificados para dar feedback visual ao user:
- VALID | INVALID :: se o valor do campo está de acordo ou não com as regras de validação
- PRISTINE | DIRTY :: pristine representa o estado inicial do campo ou form, uma vez que o user digita no campo ele se torna DIRTY e não volta mais
- UNTOUCHED | TOUCHED :: touched indica quando o user entra no campo

A diff entre DIRTY e TOUCHED é que para o campo ficar no estado DIRTY o user precisa modificá-lo

Para saber o em qual estado o campo se encontra, precisamos obrer uma referência para a diretiva ngModel do campo
<form #myForm="ngForm">
	<input name="name" [ngModel]="username" #ipt="ngModel">
	<span *ngIf="ipt.invalid">Nome inválido</span>
</form>

# VALIDATORS
Podemos atribuir as seguintes validações a um campo:
- REQUIRED
- PATTERN - REGEX => expressão regular para validar baseado no pardão informado
- minLENGTH & maxLENGTH

<form>
	<input name="name" [ngModel]="username" #ipt="ngModel"
    required minlength="5">
	<span *ngIf="ipt.invalid">Nome inválido</span>
</form>

# Para ajudar dar o feedback visual ao user, o Angular associa aos campos e ao form as classes ::
- NG-VALID | NG-INVALID
- NG-PRISTINE | NG-DIRTY
- NG-UNTOUCHED | NG-TOUCHED

ERRO na consola do Chrome logo após fazer o #iptAddress="ngModel ::
Unhandled Promise rejection: Template parse errors:
There is no directive with "exportAs" set to "ngModel" ("o</label>
            <input type="text" class="form-control" name="address" required minlength="5" [ERROR ->]#iptAddress="ngModel" placeholder="Endereço" autocomplete="off">
            <span class="help-block""): ng:///AppModule/OrderComponent.html@28:90 ; Zone: <root> ; Task: Promise.then ; Value: Error: Template parse errors: (...)

Solução no StackOverflow
https://stackoverflow.com/questions/38648407/angular2-error-there-is-no-directive-with-exportas-set-to-ngform

Solução mais simples que funcionou para mim :: apenas coloquei novamente o ngModel juntamente com o #iptAddress="ngModel" na inpunt, ficando assim:
<input type="text" class="form-control" name="address" required minlength="5" ngModel #iptAddress="ngModel" placeholder="Endereço" autocomplete="off">

------------------------------------------------------------------
# 61 Componente de Input Através de Content Projection
------------------------------------------------------------------
Criação de um componente para representar um input-text

Isto servirá para simplificar o código do template HTML e evitar a repetição de código.
Exemplo de como ficaram dois itens do formulário ::


<div class="form-group" [class.has-success]="iptAddress.valid && (iptAddress.dirty || iptAddress.touched)"
                        [class.has-error]="!iptAddress.valid && (iptAddress.dirty || iptAddress.touched)">
  <label class="control-label sr-only" for="inputSuccess"><i class="fa fa-check"></i> Endereço</label>
  <input type="text" class="form-control" name="address" required minlength="5" ngModel #iptAddress="ngModel" placeholder="Endereço" autocomplete="off">
  <span class="help-block" *ngIf="iptAddress.valid && (iptAddress.dirty || iptAddress.touched)"><i class="fa fa-check"></i> Ok</span>
  <span class="help-block" *ngIf="!iptAddress.valid && (iptAddress.dirty || iptAddress.touched)"><i class="fa fa-remove"></i> Campo obrigatório</span>
</div>
</div>
<div class="col-sm-2 col-xs-6">
<div class="form-group" [class.has-success]="iptNumber.valid && (iptNumber.dirty || iptNumber.touched)"
                        [class.has-error]="!iptNumber.valid && (iptNumber.dirty || iptNumber.touched)">
  <label class="control-label sr-only" for="inputSuccess"><i class="fa fa-check"></i> Número</label>
  <input type="text" class="form-control" name="number" required #iptNumber="ngModel" ngModel placeholder="Número" autocomplete="off">
  <span class="help-block" *ngIf="iptNumber.valid && (iptNumber.dirty || iptNumber.touched)"><i class="fa fa-check"></i> Ok</span>
  <span class="help-block" *ngIf="!iptNumber.valid && (iptNumber.dirty || iptNumber.touched)"><i class="fa fa-remove"></i> Campo obrigatório</span>          </div>
</div>

Após criar um component e substituir um destes um destes form-group pela tag do component, no browser, o feedback visual continua, porém o elemento perde a sua rastreabilidade.
Isto acontece porque o input text agora está encapsulado em outro componente e o form não consegue mais enxergá-lo.

Temos duas formas para resolver:
- Content Projection :: transformar o componente num component container, onde aplica-se apenas o estilo visual e deixa com que o component parent (o componente de compra) passe o input text
- Control Value Accessor :: deixar o componente totalmente isoladodentro do input e impolementa uma interface chamada control value accessor (serve de ponte entre as diretivas usadas de apoio ao formulário, como o ngModel e o próprio component)

CONTENT PROJECTION
- usar uma tag chamada <ng-content> no lugar do input text.
  Similar ao router-outlet (marcar uma região onde através de uma navegação entramos com um component correspondente àquele caminho), no "ng-content", ele também representa um espaço que vai entrar um conteúdo (o conte+udo que vai ficar entre as tags do component)
  No component, camos usar o decorator @ContentChild, onde dizemos qual é o elemento ou diretiva que queremos buscar uma referência

- Importat decorator Input para referenciar os atributos que irão receber infos dos parents (de fora)

- Pegar uma ref para ngModel que vai ser declarada por quem tiver usando o component (vai ficar como filho do component)
  1. import NgModel em angular/forms
  2. ContentChild em @angular/core

------------------------------------------------------------------
# 62 Validação com Expressões Regulares
------------------------------------------------------------------
Feito com o atributo pattern.

# Email Regex
`/^(([^<>()\[\]\.,;:\s@\"]+(\.[^<>()\[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i`

# Number Regex
`/^[0-9]*$/`

------------------------------------------------------------------
# 63 ControlValueAccessor
------------------------------------------------------------------
Ao usar a interface ControlValueAccessor precisa implementar os seus métodos:
- writeValue(obj: any): void;
- registerOnChange(fn: any): void;
- registerOnTouched(fn: any): void;
- setDisabledState?(isDisabled: boolean): void;

------------------------------------------------------------------
Navegação Programática via Router
------------------------------------------------------------------
- Precisa fazer import Router:
  import { Router } from '@angular/router'

- Instanciar no constructor:
  private router: Router

- Usar o método navigate()
  this.router.navigate(['/order-summary'])

------------------------------------------------------------------
REACTIVE FORMS
------------------------------------------------------------------
Nova forma que o Angular traz para implementar formulários.
Ao invés de usar ngModel e validadores nos campos criamos instancias de FORM GROUP ou FORM CONTROL
dentro de um componente.

// O form é representado por FormGroup que vai agrupar um ou mais campos dentro dele
// Pra ajudar nessa tarefa o Angula disponibiliza o obj FormBuilder, que ajuda na criação dos campos e outros grupos.
// FormBuilder tem um método chamado group({}) onde recebe um obj com propriedades representando cada campo do form.

Importações no componente ::
import { FormBuilder, FormControl, FormGroup } from '@angular/forms'

@Component({...})
export class UserComponent implements OnInit {

  userForm: FormGroup

  constructor(private fb: FormBuiler) {} ------------------------| Injetar uma instância de FormBuilder

  ngOnInit() {
    this.userForm = this.fb.group({
      username: '', -------------------------------------------- | campo iniciado com valor vazio
      password: '' --------------------------------------------- | campo iniciado com valor vazio
    })
  }
}

// --- Mesmo resultado usando o método control(), do FormBuiler

@Component({...})
export class UserComponent implements OnInit {

  userForm: FormGroup

  constructor(private fb: FormBuiler) {}

  ngOnInit() {
    this.userForm = this.fb.group({
      username: this.fb.control(''),
      password: this.fb.control('') ---------------------------- | FormControl
    })
  }
}

// --- Os validadores podem ser passados em um array ao criar o FormControl

this.userForm = this.fb.group({
  username: this.fb.control('', [validators.required]), ---------| campo obrigatório
  password: this.fb.control('', [validators.required]) ----------| tem que ter no mín 3 caracteres
})

VALIDATORS :: Reactve Forms te os validadores padrão (todos declarados como funções estáticas da classe Validators):
- minlength(..) | maxlength(..)
- required
- patern(..)

Se o form tiver campos que fazem sentido serem agrupados, pode-se fazer isso com um outro Form Group.
A vantagem de um group é que pode aplicar validadores ao nível do grupo para validar valores entre os componentes.
Ex. para o endereço:

@Component({...})
export class UserComponent implements OnInit {

  userForm: FormGroup

  constructor(private fb: FormBuiler) {}

  ngOnInit() {
    this.userForm = this.fb.group({
      username: '', -------------------------------------------- | campo iniciado com valor vazio
      password: '' --------------------------------------------- | campo iniciado com valor vazio
      address: this.fb.group({
        street: '',
        zip:
      })
    })
  }
}

Ex de como fica o template (não vai mais usar o ngModel).
O form será associado com o grupo do componente através da diretiva "formGroup".
Cada componente será associado com "formControlName":

<form [formGroupName]="userForm"> -----------------------------------| diretiva formGroupName
	<input type="text" formControlName="username"/>
  <input type="password" formControlName="password"/>
  <div formGroupName="address">
    <input type="text" formControlName="street"/>
    <input type="text" formControlName="zip"/>
  </div>
</form>

// --- A partir deste ponto, como o programa MEAT APP será refatorado de Template Forms para Reactive Forms,
foi criado um novo repositório Git:
https://github.com/dantovsky/meat-app-reactive-forms

------------------------------------------------------------------
# 73 e 74 Validators e Validação Personalizada com REACTIVE FORMS
------------------------------------------------------------------
// expressoes regulares
emailPattern = /^(([^<>()\[\]\.,;:\s@\"]+(\.[^<>()\[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i
numberPattern = /^[0-9]*$/

------------------------------------------------------------------
# 75 Módulos Angular
------------------------------------------------------------------
São itens de config do framework que servem para agregar:
- componentes
- diretivas
- serviços
- pipes
Não só com o objetivo de organizar o code. Podemos decidir:
- o que vai ser exportado para fora do módulo
- como a injeção de dependencia vai ser config

É possível configurar módulos que apenas certos users vão usar.
Com módulos é podemos dividir a app em partes independentes e definir que essas partes não sejam carregadas de imediato,
apenas quando requisitadas.
É uma feature chamada "LAZY LOADING" ou "carregamento tardio".

Tipos de Módulos
- ROOT MODULE :: onde tem a declaracão dos componentes, que são usadas na app inteira.
  É o modulo que faz o bootstrap da app. Apps pequenas pode ser suficiente ter somente este.

- SHARED MODULES :: módulo compartilhado com todos os componentes que são usados por outros módulos da app

- CORE MODULES :: com todos os serviços da app (não contem componentes, apenas serviços, ex: módolo Http)

- FEATURE MODULES :: contem as implementações das funcionalidades da app.

Para declarara um módulo precisamos da uma classe associada com o decorator @NgModule(), mas diferente do módulo raiz,
este não tem bootstrap, e precisamos listar os componentes que queremos que sejam visíveis fora do módulo no atributo export.
Sem isso os componentes são visíveis apenas internamente.

@NgModule({
  declarations: [...],
  imports: [...],
  providers: [...],
  exports: [...] ---------------------| Componentes que serão visíveis de fora
})
export class MyModule {}

LAZY LOADING
O Router é que faz o Lazy Loading. Quando aciona uma certa rota é que ele vai realmente carregar um certo módulo nesse momento.
Precisa informar na app.routes.ts que quer carregar um determinado componente apenas de forma tardia.

# FEATURE MODULE :: Exemplo para o caso do AboutComponent
1. em app.module.ts, retirar a referencia ao componente: import { AboutComponent } from './about/about.component' e retirar o AboutComponent de "declarations: [...]"
2. em app.routes.ts, alterar a rota, de { path: 'about', component: AboutComponent } para { path: 'about', loadChildren: './about/about.module#AboutModule' }
3. em about.module.ts deve importar o RouterModule e Routes para especificar a rota padrão, e importar o método RouterModule.forRoot(ROUTES)
  import { RouterModule, Routes } from '@angular/router'
  const ROUTES: Routes = [
    { path: '', component: AboutComponent }
  ]
  @NgModule({imports: [RouterModule.forChild(ROUTES)]})

# SHARED MODULE

------------------------------------------------------------------
# 80 Objeto ModuleWithProviders
------------------------------------------------------------------
O objeto ModuleWithProviders permite configurar um módulo diferente para determinadas situações.
Ex: no módulo SharedModule, foi criado uma funcao estática:

export class SharedModule {
  // funcao que retorna um módulo com providers, que é basicamente a config do módulo + os providers que vamos importar aqui
  static forRoot(): ModuleWithProviders {
    return {
      ngModule: SharedModule, // ja vai ter todas as configs necessárias para importar em outros lugares
      providers: [ShoppingCartService, RestaurantsService, OrderService]
    }
  }
}

Em app.module estamos importando como "SharedModule.forRoot()" para que também venham os providers.
Em order.module chamamos apenas "SharedModule".

------------------------------------------------------------------
# 81 Realizando Pré-Carregamento de Todos os Módulos (Preloading)
------------------------------------------------------------------
Embora possamos criar módulos com o carregamento tardio, podemos realizar um carregamento antecipado destes módulos, mas em background.

Em app.module importar o PreloadAllModules:
import { RouterModule, PreloadAllModules } from '@angular/router';

E quando carregar as rotas (em imports), nós passamos a estratégia de carregamento:
imports: [
  ...
  RouterModule.forRoot(ROUTES, { preloadingStrategy: PreloadAllModules })
],

------------------------------------------------------------------
# 82 ANIMATIONS
------------------------------------------------------------------
https://www.w3.org/TR/css-transitions-1/#animatable-properties

importações:
- @angular/animations
  npm install --save @angular/animations@4.0.0 (--save para salvar nas dependências do projeto e versão 4.0.0 para manter a compatibilidade com os outros módulos que já tem no projeto)
- polyfill (para browsers que não suportam a Web Animations API)
  npm install --save web-animations-js
- configurar o Browser Animations Module

Próximos passos:
- configurar o polyfill.js
  import 'web-animations-js/web-animations.min.js'
- importar o Browser Animations Module no módulo principal
  import { BrowserAnimationsModule } from "@angular/platform-browser/animations"
  imports: [
    ...
    BrowserAnimationsModule,
    ...
  ]


Entre dois estados (por ex: botão normal e esticado), pode-se fazer uma transição: duração/delay/aceleração

import { trigger, state, style, transition, animate } from '@angular/animations'

@Component({
  template: `<button [@stretch]="buttonState">Click</button>`
  animations: [
    trigger('stretch', [ -----------------------------------| 1º param é o nome para a funcao trigger
      state('normal', style({width: '40px'})),
      state('stretched', style({width: '120px'})),
      transition('normal => stretched', animate('300ms')),
      transition('stretched => normal', animate('500ms'))
    ]) -----------------------------------------------------| 2º param é um array de estados
  ]
})
export class ButtonComponent { buttonState = 'normal' }

O Angular fornece dois estados especiais:
- WILDCARD* :: usado para representar qualquer estado
- VOID :: usado para representar a transicao que nao está na arvore de componentes (não está no DOM) ainda ou que vai sair da arvore de componentes
  Se tivermos duas transições identicas podemos usar o Wildcard:
    transition('normal => stretched', animate('500ms')),
    transition('stretched => normal', animate('500ms'))
    // ----- passaria a ficar assim:
    transition('* => *', animate('500ms'))

# Definindo um Snackbar
Ex: https://www.w3schools.com/howto/howto_js_snackbar.asp

Criei um componente dentro de shared/messages/
E:\Dropbox\Dantiii\Cursos\Udemy\angular\meat-app-reactive-forms (master -> origin)
λ ng g c shared/messages/scackbar --spec=false

Após isto, em shared.module.ts será importado automaticamente este novo componente filho,
mas é preciso especificá-lo na lista de exports.

Em snack.component.ts ::
import { Component, OnInit } from '@angular/core';
import { trigger, state, style, transition, animate } from '@angular/animations'
@Component({
  selector: 'mt-scackbar',
  templateUrl: './scackbar.component.html',
  styleUrls: ['./scackbar.component.css'],
  animations: [
    trigger('snack-visibility', [
      state('hidden', style({
        opacity: 0,
        bottom: 0
      })),
      state('visible', style({
        opacity: 1,
        bottom: '30px'
      })),
      transition('hidden => visible', animate('1100ms 0s ease-in')),
      transition('visible => hidden', animate('1100ms 0s ease-out'))
    ])
  ]
})
export class ScackbarComponent implements OnInit {
  message: string = 'Hello there!'
  snackVisibility: string = 'hidden'
  constructor() { }
  ngOnInit() {
  }
  // para testar a anumação: criamos um botão no template: <button (click)="toggleSnack()">Click me</button>
  // toggleSnack() {
  //   this.snackVisibility = this.snackVisibility === 'hidden' ? 'visible' : 'hidden'
  // }
}

Em snack.component.html ::
<button (click)="toggleSnack()">Click me</button>
<div class="snackbar" [@snack-visibility]="snackVisibility">
  {{message}}
</div>

Em snack.component.css ::
.snackbar {
  min-width: 250px;
  margin-left: -125px;
  background-color: #333;
  color: #fff;
  text-align: center;
  border-radius: 2px;
  padding: 16px;
  position: fixed;
  z-index: 1;
  left: 50%;
  bottom: 30px;
}

# Aula 86 - Usando Observable com a snackbar

Foi criado um arquivo notification.sevice.ts dentro da pasta messages ::
import { EventEmitter } from "@angular/core";
export class NotificationService {
  notifier = new EventEmitter<string>()

  // Funcao que recebe str e passa essa msg para o metodo emit() do notifier
  notify(message: string) {
    this.notifier.emit(message)
  }
}

Depois, em shared.module.ts foi importado o componente NotificationService e colocado na lista de providers.

Em shopping-cart.service.ts fez ::
- import de NotificationService
- import de Injectable (porque esse componente vai receber algo)
- colocado o decorator @Injectable()
- na class, cirou o construtor inicializando o serviço de notificacoes :: constructor(private notificationService: NotificationService) { }
- na funcao addItem() :: this.notificationService.notify(`Você adicionou o item ${item.name}`)
- na fucnao removeItem() :: this.notificationService.notify(`Você removeu o item ${item.menuItem.name}`)

Em snackbar.component.ts ::
- import { Observable } from 'rxjs/Observable'
- import 'rxjs/add/observable/timer'
- em @ngOnInit() ::
  ngOnInit() {
    // inscrever-se para as notificações
    this.notificationService.notifier.subscribe(message => {
      this.message = message
      this.snackVisibility = 'visible'
      Observable.timer(3000).subscribe(timer => this.snackVisibility = 'hidden')
    })
  }

Contudo, com essa configuração o comportamento do snackbar ainda não está aceitável, sendo confuso quando adicionamos em vários itens
Será resoldifo com os seguintes operadores:

# Operadores DO e SWITCHAP
- import dos dois operadores:
  import 'rxjs/add/operator/do'
  import 'rxjs/add/operator/switchMap'
- refatoração do ngOnInit()
  ngOnInit() {
    // inscrever-se para as notificações
    this.notificationService.notifier
      .do(message => {
        this.message = message
        this.snackVisibility = 'visible'
      }).switchMap(message => Observable.timer(3000)) // o switchMap faz o unsubscribe, caso ainda exista algum ativo e aciona um novo subscribe
      .subscribe(timer => this.snackVisibility = 'hidden')
    // Observable.timer(3000).subscribe(timer => this.snackVisibility = 'hidden')
  }

------------------------------------------------------------------
# 88 Animação com Void e Estilos em Transições
------------------------------------------------------------------
Em restaurant.component.ts foi criado uma animação que sai do estado VOID para o estado criado
a que chamamos "ready":
import { Component, OnInit, Input } from '@angular/core';
import { trigger, state, style, transition, animate } from '@angular/animations' --------------| adicao dos imports para a animação
import { Restaurant } from './restaurant.model'
@Component({
  selector: 'mt-restaurant',
  templateUrl: './restaurant.component.html',
  animations: [ -------------------------------------------------------------------------------| implementacao do trigger, estado e transições da animação
    trigger('restaurantAppeared', [
      state('ready', style({ opacity: 1 })),
      transition('void => ready', [
        style({ opacity: 0, transform: 'translate(-30px, -10px)' }),
        animate('500ms 0s ease-in-out')
      ])
    ])
  ]
})
export class RestaurantComponent implements OnInit {
  restaurantState = 'ready' -------------------------------------------------------------------| atributo de estado
  @Input() restaurant: Restaurant
  constructor() { }
  ngOnInit() {
  }
}

Em restaurant.component.html:
<a [routerLink]="['/restaurants', restaurant.id]">
  <div class="place-info-box" [@restaurantAppeared]="restaurantState"> ------------------------| Associação do trigger ao elemento HTML e associar a trigger ao seu estado guardado na propriedade restaurantState (o arroba @ indica que é uma trigger)
    <span class="place-info-box-icon"><img [src]="restaurant.imagePath" /></span>
    <div class="place-info-box-content">
      <span class="place-info-box-text">{{restaurant.name}}</span>
      <span class="place-info-box-star"><i class="fa fa-star"></i> {{restaurant.rating}}</span>
      <span class="place-info-box-detail">{{restaurant.category}}</span>
      <span class="place-info-box-detail">{{restaurant.deliveryEstimate}}</span>
    </div>
    <!-- /.info-box-content -->
  </div>
</a>

------------------------------------------------------------------
# 90 Animação com Keyframes
------------------------------------------------------------------
São animações que contêm vários "marcos ou passos", onde cada passo vai ter um estilo de CSS diferente.
Com keyframes é possível criar animações mais complexas do que uma animação tradicional.

-> keyframes é passado como 2º argumento da funcao animate
-> a funcao keyframes recebe um array de estilos

@Component({
  animations: [
    trigger('tgr', [
      ...
      transition('st1 => st2', [
      animate('500ms 0s ease-in-out', keyframes([
        style({transform: 'transform(0px, 0px)', offset:0})
        style({transform: 'transform(100px, 0px)', offset:0.6})
        style({transform: 'transform(140px, -30px)', offset:1})
      ]))
      ])
    ])
  ]
})

Nestes outro exemplo, variam a opacidade e largura ::

@Component({
  animations: [
    trigger('tgr', [
      ...
      transition('st1 => st2', [
      animate('500ms 0s ease-in-out', keyframes([
        style({opacity: 0, width: '100px', offset:0})
        style({opacity: 0.8, width: '120px', offset:0.8})
        style({opacity: 1, width: '100px', offset:1})
      ]))
      ])
    ])
  ]
})

------------------------------------------------------------------
# 93 Rotas com Wildcard (Criando Página Não Encontrada)
------------------------------------------------------------------
Criamos um componente com o template da página 404
Nas rotas (app.routes.ts), adicionamos o caminho para "wildcard root" (**) => para indicar que nenhuma rota foi encontrada
{ path: '**', component: NotFoundComponent }

------------------------------------------------------------------
# 94 Construindo a Aplicação (BUILD)
------------------------------------------------------------------

- Build de desenvolvimento: compilação em tempo de exibição -> "just in time" (contece de forma dinâmica, dentro do browser) ::
  ng build ---------------------| constroi a app ainda com as configs de desenvolvimento

- Build de produção: compilação "ahead of time" (acontece antes de a gente servir os recursos para o browser, acontece de forma estática)
  ng build --prod --------------| build de produção (maneira reduzida)

# Angular 2 / 4 / 5 - Set base href dynamically
https://stackoverflow.com/questions/38112891/angular-2-4-5-set-base-href-dynamically

------------------------------------------------------------------
# 95 Modificando a Estratégia de Navegação (Hash)
------------------------------------------------------------------
No ambiente de produção, ao tentar aceder a uma URL diretamente, recebemos um err 404, ex:
http://localhost/dashboard/meat-app/restaurants/bread-bakery/menu

Para corrigir isso, basta usar o modelo de URL com o # (hash), onde este símbolo irá dizer para o servidor
para ignorar tudo o que tem após ele, sendo assim, é servido o index.html que faz o bootstrap da app, o Angular vai
olhar a URL, da URL bate a rota e da rota bate o componente, onde então é exibido o componente.

Em app.module.ts ::
import { LocationStrategy, HashLocationStrategy } from '@angular/common'
providers: [{ provide: LocationStrategy, useClass: HashLocationStrategy }]

# Testar a app :: RUN A WEB SERVER FROM ANY FOLDER
https://flaviocopes.com/local-web-server/

If you use Node.js and you have installed npm already, run
npm install -g http-server
and then run http-server in the folder you want to expose through your server.

By default it will start the server on port 8080, but you can change it using the -p flag
(see more options by running http-server --help).

If you use Python and have it installed, just run (to start a local server on port 8080)
(Python 2) :: python -m SimpleHTTPServer 8080
(Python 3) :: python -m http.server 8080

If you use PHP and you run a modern version of it, run:
php -S localhost:8080

# Também é possível servir a app com as configs de produção :: (subir um servidor de desenvolvimento com as configs de produção)
ng serve --prod

------------------------------------------------------------------
# Deploy de uma Aplicação
------------------------------------------------------------------

# 97 Deploy no Apache HTTP Server
Se o build foi gerado com o comando "ng build --prod":
Basta colocar os arquivos da pasta dist na raiz do servidor.

# 98 Deploy Usando a Estratégia de Caminho - Apache HTTP Server
Nessa estratégia, vai exigir que a gente configure o Apache para retornar o index.html quando ele não encontrar um recurso que a gente pedir.

Removeu-se, portanto, a hash (aula 95) e coloca-se uma regra no:
- .htaccess
- ou então no arquivo httpd.conf (C:\xampp\apache\conf). ----------| precisa ter o rewrite_module habilitado (LoadModule rewrite_module modules/mod_rewrite.so)
  Foi adicionado antes da tag de término </Directory>
No caso de servidores, penso que apenas os server VPS disponibilizam o acesso a esta configuração do Apache.
O site do Apache recomenda que seja no arquivo httpd.conf, pois sendo no .htaccess perde um pouco de desempenho.

Deployment
https://angular.io/guide/deployment

-> Apache: add a rewrite rule to the .htaccess file as shown (https://ngmilk.rocks/2015/03/09/angularjs-html5-mode-or-pretty-urls-on-apache-using-htaccess/):
RewriteEngine On
    # If an existing asset or directory is requested go to it as it is
    RewriteCond %{DOCUMENT_ROOT}%{REQUEST_URI} -f [OR]
    RewriteCond %{DOCUMENT_ROOT}%{REQUEST_URI} -d
    RewriteRule ^ - [L]
    # If the requested resource doesn't exist, use index.html
RewriteRule ^ /index.html

-> Nginx: use try_files, as described in Front Controller Pattern Web Apps, modified to serve index.html:
try_files $uri $uri/ /index.html;

-> IIS: add a rewrite rule to web.config, similar to the one shown here:
<system.webServer>
  <rewrite>
    <rules>
      <rule name="Angular Routes" stopProcessing="true">
        <match url=".*" />
        <conditions logicalGrouping="MatchAll">
          <add input="{REQUEST_FILENAME}" matchType="IsFile" negate="true" />
          <add input="{REQUEST_FILENAME}" matchType="IsDirectory" negate="true" />
        </conditions>
        <action type="Rewrite" url="/index.html" />
      </rule>
    </rules>
  </rewrite>
</system.webServer>
GitHub Pages: you can't directly configure the GitHub Pages server, but you can add a 404 page. Copy index.html into 404.html. It will still be served as the 404 response, but the browser will process that page and load the app properly. It's also a good idea to serve from docs/ on master and to create a .nojekyll file

-> Firebase hosting: add a rewrite rule.
"rewrites": [ {
  "source": "**",
  "destination": "/index.html"
} ]

# 99 Deploy Usando o arquivo htaccess - Apache HTTP Server
- No arquivo httpd.conf a opção AllowOverride precisa estar como "AllowOverride All"
- criar um arquivo .htaccess na pasta raiz da app e colar a regra no arquivo:
  RewriteEngine On
      # If an existing asset or directory is requested go to it as it is
      RewriteCond %{DOCUMENT_ROOT}%{REQUEST_URI} -f [OR]
      RewriteCond %{DOCUMENT_ROOT}%{REQUEST_URI} -d
      RewriteRule ^ - [L]
      # If the requested resource doesn't exist, use index.html
  RewriteRule ^ /index.html

# 100 Modificando o base-href para Deploys em Subdiretórios (Seção 11, aula 100)
Exemplo para ter a app dentro de uma pasta chamada meat (localhost/meat/)
- ng build --prod --bh=/meat/ ----------------------| versão abreviada
- ng build --prod --base-href /meat/ ---------------| versão completa
  Neste caso, para que os caminhos nunca quebrem, deve mudar este item na regra do .htaccess ::
  Em vez de
  RewriteRule ^ /index.html
  use
  RewriteRule ^ /meat/index.html

------------------------------------------------------------------
# 104 Observable ValueChanges de Reactive Forms
------------------------------------------------------------------
O FormControl tem uma prop chamada valuChanges (que é um Observable)
Podemos subscrever para que sempre que for digitado um valor no campo (quando o valor mudar)
irá gerar um evento e quem estiver inscrito no valuChanges vai receber uma notificação.

------------------------------------------------------------------
# 105 Operadores debounceTime e distinctUntilChanged
------------------------------------------------------------------
Essa implementação foi para que ao digitar um termo de pesquisa o sistema espere 500ms
entre um termo digitado e outro para realizar a consulta ao servidor
e entre dois termos digitados, ele só envia a nova consulta se os termos forem diferentes (dinstintos) .

// debounceTime(500) :: só vai deixar emitir um evento se a diferença entre dois eventos for maior que o tempo informado (milissegundos)
// distictiUltilChanged() :: vai permitir apenas as mensagens que são diferentes umas das outras (se a mensagem seguinte for igual a da anterior, ele não vai mais subscrever a nova mensagem)
//
// do(function(searchTerm) { console.log(searchTerm) }) :: pode ser usado para debuggar no console o que o sistema está enviando para fazer o pedido a "API Server"
//
// switchMap() :: quando chega uma nova mensagem, o swichMap() faz o unsubsscribe do anterior. O switchMap irá resolver problemas entre vários requests que demoram tempos diferentes (muito comum com o uso da internet)

------------------------------------------------------------------
# 106 Prevenindo a interrupção do Observable ValueChanges
------------------------------------------------------------------
Como na input de pesquisa temos uma stream em aberto, pode acontecer um erro no back-end, esse erro vai subir e quebrar
o Observable ValueChanges (vai parar de funcionar).

O que fazer?
Utilização de catch no Observable que faz a query via HTTP, e nesse catch temos que capturar e tratar o valor.
A função que se passa para o catch temos que devolver um outro Observable, e nesse outro Observable a gente escolhe o que vai retornar.
Podemos:
- logar o erro
- mandar msg para o user
- e então, retornar dados vazios nessa query

Imports ::
import 'rxjs/add/operator/catch'
import 'rxjs/add/operator/from' // usado para criar uma string a partir de um array
import { Observable } from 'rxjs/Observable'

// Se inscrever no atributo valueChanges para ouvir o que o user está digitando
// em vez de fazer um subscribe para pegar o termo e depois fazer outro subscribe
// vamos utilizar o switchMap para poder trocar o Observable e fazer o subscribe uma vez só
//
// debounceTime(500) :: só vai deixar emitir um evento se a diferença entre dois eventos for maior que o tempo informado (milissegundos)
// distictiUltilChanged() :: vai permitir apenas as mensagens que são diferentes umas das outras (se a mensagem seguinte for igual a da anterior, ele não vai mais subscrever a nova mensagem)
//
// do(function(searchTerm) { console.log(searchTerm) }) :: pode ser usado para debuggar no console o que o sistema está enviando para fazer o pedido a "API Server"
//
// switchMap() :: quando chega uma nova mensagem, o swichMap() faz o unsubsscribe do anterior. O switchMap irá resolver problemas entre vários requests que demoram tempos diferentes (muito comum com o uso da internet)
//
// catch() :: vamos usar um catch no observable de retorno do swichMap para não deixar o erro estourar e quebrar o ValueChange

ngOnInit() {
  this.searchControl.valueChanges
    .debounceTime(500)
    .distinctUntilChanged()
    .switchMap(searchTerm =>
      this.restaurantsService
        .restaurants(searchTerm)
        .catch(error => Observable.from([]))) ------------------------| adicionamos o catch dentro do swichMap() para tratar o erro e enviar um array vazio [] quando encontrar um erro
    .subscribe(restaurants => this.restaurants = restaurants)
}

------------------------------------------------------------------
# 107 Novo Módulo HttpClient
------------------------------------------------------------------
Vantagens do novo módulo:
- não é mais necessário usar o operador map() pra retornar o corpo da resposta, agora já retorna automaticamente
- respostas tipadas: ajuda na detecção de erros

# Exemplos e comparação

MUDANÇAS NO IMPORT
------------------

=> Antes no HttpModule
import { HttpModule } from '@angular/core'
@NgModule({
  imports: [HttpModule]
})
export class AppModule {}

=> Novo módulo HttpClient (não é mais necessário add o pacote do módule anterior no package.json da app)
import { HttpClientModule } from '@angular/common/http'
@NgModule({
  imports: [HttpClientModule]
})
export class AppModule {}

MUDANAS NO USO
--------------
Não injetamos mais Http, mas sim HttpClient

import { HttpClient } from '@angular/common/http'
@Injectable()
export class MyService {
  constructor(private http: HttpClient) {}
}

MÉTODOS
-------
Os mesmos: GET, POST, DELETE, PUT
- Retornam o body
  sem map()
- Respostas tipadas: ajudando na deteção de erros

USANDO HTTP
restaurantById(id: string): Observable<Restaurant> {
  return this.http.get(`restaurants/${id}`)
    .map(response => response.json())
}

USANDO HttpClient (novo método)
restaurantById(id: string): Observable<Restaurant> {
  return this.http.get<Restaurant>(`restaurants/${id}`) ----------------------------| necessidade de tipar o retorno do método get
}

COMO ACESSAR MAIS INFORMAÇÕES DA RESPOSTA (ex: acessar um header)
this.http.get<Restaurant[]>(`/restaurants`, {observe: 'response'}) ----------------------------| necessidade de tipar o retorno do método get
         .subscribe(rest => {
            resp.headers.get('X-PageSize') // custom header
            this.rests = resp.body // Restaurant[]
         })
// Isso vai fazer com que a resposta seja disponibilizada diretamente e podemos inspecioná-la antes de ler o valor do corpo,
// cujo qual pode ser obtivo através da propriedade "body"

------------------------------------------------------------------
# 108 Refactoring para o Novo Módulo HttpClient
------------------------------------------------------------------

Dependências antigas ::
"dependencies": {
  "@angular/animations": "^4.0.0",
  "@angular/common": "4.0.0",
  "@angular/compiler": "4.0.0",
  "@angular/core": "4.0.0",
  "@angular/forms": "4.0.0",
  "@angular/http": "4.0.0",
  "@angular/platform-browser": "4.0.0",
  "@angular/platform-browser-dynamic": "4.0.0",
  "@angular/router": "4.0.0",
  "admin-lte": "2.3.11",
  "core-js": "2.4.1",
  "font-awesome": "4.7.0",
  "intl": "1.2.5",
  "jquery": "3.1.1",
  "reflect-metadata": "0.1.9",
  "rxjs": "5.1.0",
  "ts-helpers": "1.1.2",
  "web-animations-js": "^2.3.1",
  "zone.js": "0.8.4"
},
"devDependencies": {
  "@angular/cli": "1.2.7",
  "@angular/compiler-cli": "4.0.0",
  "@types/jasmine": "2.5.38",
  "@types/node": "7.0.5",
  "codelyzer": "2.0.0",
  "jasmine-core": "2.5.2",
  "jasmine-spec-reporter": "3.2.0",
  "karma": "1.4.1",
  "karma-chrome-launcher": "2.0.0",
  "karma-cli": "1.0.1",
  "karma-jasmine": "1.1.0",
  "karma-remap-istanbul": "0.2.2",
  "protractor": "5.1.0",
  "ts-node": "2.1.0",
  "tslint": "4.5.0",
  "typescript": "2.2.0",
  "webdriver-manager": "10.2.5"
}

Dependências novas ::
"dependencies": {
    "@angular/animations": "4.3.3",
    "@angular/common": "4.3.3",
    "@angular/compiler": "4.3.3",
    "@angular/core": "4.3.3",
    "@angular/forms": "4.3.3",
    "@angular/platform-browser": "4.3.3",
    "@angular/platform-browser-dynamic": "4.3.3",
    "@angular/router": "4.3.3",
    "admin-lte": "2.3.11",
    "core-js": "2.4.1",
    "font-awesome": "4.7.0",
    "intl": "1.2.5",
    "jquery": "3.1.1",
    "reflect-metadata": "0.1.10",
    "rxjs": "5.4.2",
    "ts-helpers": "1.1.2",
    "web-animations-js": "2.2.5",
    "zone.js": "0.8.16"
  },
  "devDependencies": {
    "@angular/cli": "1.2.7",
    "@angular/compiler-cli": "4.3.3",
    "@types/jasmine": "2.5.53",
    "@types/express": "4.0.37",
    "@types/jsonwebtoken": "7.2.3",
    "@types/node": "7.0.5",
    "codelyzer": "3.1.2",
    "jasmine-core": "2.7.0",
    "jasmine-spec-reporter": "4.1.1",
    "json-server": "0.12.0",
    "jsonwebtoken": "7.4.1",
    "karma": "1.7.0",
    "karma-chrome-launcher": "2.2.0",
    "karma-cli": "1.0.1",
    "karma-jasmine": "1.1.0",
    "karma-remap-istanbul": "0.6.0",
    "protractor": "5.1.2",
    "ts-node": "3.3.0",
    "tslint": "5.5.0",
    "typescript": "2.4.2",
    "webdriver-manager": "12.0.6"
  }

------------------------------------------------------------------
# 109 Personalizando o Backend
------------------------------------------------------------------
https://github.com/typicode/json-server
https://expressjs.com/en/starter/hello-world.html

const jsonServer = require('json-server')
const server = jsonServer.create() ---------------------------------| server é uma aplicação Express
const router = jsonServer.router('db.json')
const middlewares = jsonServer.defaults()

// Set default middlewares (logger, static, cors and no-cache)
server.use(middlewares)

// Add custom routes before JSON Server router
server.get('/echo', (req, res) => {
  res.jsonp(req.query)
})

// To handle POST, PUT and PATCH you need to use a body-parser
// You can use the one used by JSON Server
server.use(jsonServer.bodyParser)
server.use((req, res, next) => { ------------------------------------| callback de três params => middleware (pode ler os dados do request, pode fazer uma tarefa e ao final pode chamar a função next(), passando para o "próximo da fila", os outros callbacks)
  if (req.method === 'POST') {
    req.body.createdAt = Date.now()
  }
  // Continue to JSON Server router
  next()
})

// Use default router
server.use(router)
server.listen(3000, () => {
  console.log('JSON Server is running')
})

// - - -

server.use() -------------------------------------------------------| especifica que o callback vai funcionar para qualquer método HTTP e para qualquer rota caso retire o parametro da rota

// - - -

// Ficamos apenas com esse código ::
const jsonServer = require('json-server')
const server = jsonServer.create()
const router = jsonServer.router('db.json')
const middlewares = jsonServer.defaults()

// Set default middlewares (logger, static, cors and no-cache)
server.use(middlewares)

// To handle POST, PUT and PATCH you need to use a body-parser
// You can use the one used by JSON Server
server.use(jsonServer.bodyParser)

// Use default router
server.use(router)
server.listen(3000, () => {
  console.log('JSON Server is running')
})

------------------------------------------------------------------
# 110 Utilizando HTTPS e TypeScript
------------------------------------------------------------------
1) alteramos a extensão do arquivo para server.ts
2) Quando temos uma app em TypeScript, precisamos ter um arquivo com as configs do compilador
- criar na pasta do "backend" o arquivo: tsconfig.json

Conteúdo do arquivo tsconfig.json
{
  "compileOnSave": true, ------------------------------| compila automaticamente para JavaScript ao salvar
  "compilerOptions": { --------------------------------| indica a pasta onde ficarão os arquivos JS compilados (dir de saída)
    "outDir": "dist"
  }
}

// Se estivermos num IDE que nao tem suporte ao compileOnSave podemos fazer
tsc -w
no diretório do backend

// - - - Versão em TS ::

import * as  jsonServer from 'json-server'
import { Express } from 'express' // tipo que representa uma app em Express

// módulo para configurar o HTTPS, capaz de ler o certificado e a privatekey
import * as fs from 'fs' // file system
import * as https from 'https'

const server: Express = jsonServer.create()
const router = jsonServer.router('db.json')
const middlewares = jsonServer.defaults()

// Set default middlewares (logger, static, cors and no-cache)
server.use(middlewares)

// To handle POST, PUT and PATCH you need to use a body-parser
// You can use the one used by JSON Server
server.use(jsonServer.bodyParser)

// Use default router
server.use(router)

// antes de chamar o método listen(), vamos 1º obter uma ref ao cert e a key
const options = {
  cert: fs.readFileSync('./backend/keys/cert.pem'),
  key: fs.readFileSync('./backend/keys/key.pem')
}

https.createServer(options, server).listen(3001, () => {
  console.log('JSON Server is running on https://localhost:3001')
})

/// - - - Automatizando o restart do server, quando ocorre mudança
- instalar o pacote nodemon
  node istall nodemon -g

- rodar o nodemon para monitorar e automatizar o server
  nodemon --watch backend backend/dist/server.js ----------------------| vai monitorar os arquivos da pasta "backend" e vai executar o script em "backend/dist/server.js"

------------------------------------------------------------------
# 111 Implementando a Rota de Login
------------------------------------------------------------------
Postman :: para testar os métodos HTTP
https://www.getpostman.com/downloads/

Status de erros
400 :: Bad Request
401 :: não autorizado (tentativa de acesso a uma URL protegida por login)
403 :: autenticação inválida; quando é válida mas o user não tem permissão para aceder a tal recurso
422 :: comum em API Rest: Unprocessable Entity

Para identificar o user vai ser usado o Token JWT

------------------------------------------------------------------
# 112 Intro ao JWT
------------------------------------------------------------------
O que é um TOKEN?
Um dado que serve para identificar uma parte interessada, que pode ser um user ou até mesmo outro app.
Aquele que tem a posse de um TOKEN tem o direito de aceder ou fazer algo em um sistema.

O que é JWT?
JSON Web Token
Surgiu para propor um padrão de formato de tokens p apps web que precisam identificar ou dar permissão a uma das partes.

# Estrutura de um Token JWT

HEADER
formato JSON, onde enviamos as infos sobre o token
{
  "alg": "H256", -----------------------------------| algoritmo usado para assinar o token
  "typ": "JWT" -------------------------------------| tipo do token (opcional)
}
Os campos que carregam essa info são chamados de clams

PAYLOAD (corpo)
formato JSON, carregam indos (clams) que são de interesse da app, e podem ser classificados como:
- registados: os definidos pela especificação de JWT
- publico
- privados

Entre os clams "registrados", destacam-se os (sub, iss e exp):
{
  "sub": "user@host.com", -----------------------| subject :: representa o principal interessado (algo que ident o user)
  "iss": "my-tokem-manager", --------------------| issuer :: representa quem gerou o token
  "exp": "1503183549" ---------------------------| tempo de expiração
}

A app também pode add clams(chamados de privados): interessam apenas àqueles que produzem e consomem o token
{
  "profile": "admin",
  "name": "John",
  "sub": "user@host.com", -----------------------| representa o principal interessado (algo que ident o user)
  "iss": "my-tokem-manager", --------------------| representa quem gerou o token
  "exp": "1503183549" ---------------------------| tempo de expiração
}

SIGNATURE

Para formar o token, o header e corpo são dodificados com BASE64 URL e unidos po um ponto.
A assinatura é opcional.
Ex:
HEADER.PAYLOAD.SIGNATURE
"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
.eyJzdWIiOiJqdWxpYW5hQGdtYWlsLmNvbSIsImlzcyI6Im1lYXQtYXBpIiwiaWF0IjoxNTQ5MjEzMDI2fQ
.uZ9CyOL9YPAoQJha-K6fXFdJA1sJV4e2Ujfrgkjx7Sg"

USO ::
jwt.sign({ sub: dbUser.email, iss: 'meat-api' }, 'meat-api-password') ------| o 2º param é a senha para assinar o token

------------------------------------------------------------------
# 120 Protegendo o Módulo de Compra com CanLoad
------------------------------------------------------------------
Route Guards (guardas de rotas) :: vamos apresentar a tela de login
caso o user não esteja autenticado quando for finalizar uma compra.

Formas de implementar:
- criar uma funcao com a mesma assinatura que tem um método da interface que qeur implementar
- declarar o guard como um provider :: mais flexivel, pois um provider pode receber outros objetos que tambem sao gerenciados pelo container de injeção de dependencias do Angular. Entao o guard precisa entrar em contato com o LoginService para saber se o user está logado.
Tipos:
- CANLOAD

------------------------------------------------------------------
# 121 Protegendo o Módulo de Compra com CanActivate
------------------------------------------------------------------
Situação: o user pode entrar no sistema, fazer logoff e poder entrar novamente, uma vez que a gente já carregou essa rota.

// -------------- Implementação do CanLoad e CanActivate em loggedin.guard.ts

import { CanLoad, Route, CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot } from "@angular/router";
import { Injectable } from "@angular/core";
import { LoginService } from "./login/login.service";

@Injectable()
export class LoggedIdGuard implements CanLoad, CanActivate {

  constructor(private loginService: LoginService) { }

  // funcao auxiliar para o o canLoad() e o canActivate()
  checkAuthentication(path: string): boolean {
    const loggedin = this.loginService.isLoggedIn()
    if (!loggedin) {
      this.loginService.handleLogin(`/${path}`)
    }
    return loggedin
  }

  // método que recebe um param que diz pra gente qual é a config da rota que a gente associou o LoggedIdGuard
  canLoad(route: Route): boolean { //| Observable<boolean> | Promise<boolean>
    return this.checkAuthentication(route.path)
  }

  // no canActivate() temos todas as infos da rota que vai ser ativada (params e outras refs a outros obj e todas as rotas parents)
  // ActivatedRouteSnapshot :: representa a rota a rota já ativada
  // RouterStateSnapshot :: é uma arvore de ActivatedRouteSnapshot (vai ter todo o caminho de todas as rota ativadas até chegar na nossa). Poderíamos também conseguir acessar os snapshots das rotas parents.
  canActivate(activatedRoute: ActivatedRouteSnapshot, routerState: RouterStateSnapshot): boolean {
    return this.checkAuthentication(activatedRoute.routeConfig.path)
  }
}

// -------------- Implementação da rota em app.routes.ts
...
{
  path: 'order', loadChildren: './order/order.module#OrderModule',
  canLoad: [LoggedIdGuard], canActivate: [LoggedIdGuard]
},
...

------------------------------------------------------------------
# 123 Implementando Route Guard CanDeactivate na Compra
------------------------------------------------------------------
3 passos para implementar:
- criar a classe
- declarar como provider
- associar na rota (a que fica dentro de order.module.ts)

------------------------------------------------------------------
# 124 HTTPCLIENT - INTERCEPTORS
------------------------------------------------------------------
HTTP Interceptors são uma grande adição feita pelo novo módulo HttpClient.
Com esse mecanismo uma app consegue capturar o momento anterior ou posterior
a uma chamada HTTP e fazer alterações comuns a todas as chamadas, como por exemplo:
-  atribuir um novo header a requisicao dinamicamente, sem precisar colocar em vários pontos da app

O que fazer com Interceptors?
- logging :: logar quando a req está sendo feita, e com o que (o que vai no req)
- profiling :: usado p caulcular o tempo que as req ao backend estão levando (de modo a descobrir os pontos a otimizar)
- error handling :: interceptar a resposta e promover um tratamento de erro global para a app

------------------------------------------------------------------
# 127 Utilizando Zonas
------------------------------------------------------------------
Faz com que códigos executem dentro de uma zona.
Ex: uma inconsistência no ErrorHandler que dispara ou esconde as notificações em momentos errados
pode ser corrigido utilizando zonas (o código do ErrorHandler precisa estar dentro de uma zona).

Também vai servir para as situações onde usamos uma biblioteca com uma função async, e o Angulo pode acabar por perceber
que a execução existiu, então podemos corrigir garantindo que esse code executa dentro de uma zona.










// ------------------------------------------
// -------- Comentários para commit ---------
// ------------------------------------------
# Aula 108 - Refactoring da app :: retirou-se o HttpModule e colocou o HttpClientModule, e de Http para HttpClient, todos importados from @angular/common/http. O import Response foi trocado por HttpErrorResponse. Não é necessário mais usar o map() nas funções porque agora já retornam um JSON.

Deploy no Apache HTTP Server, deploy usando a estratégia de caminho (path, uma opção alternativa à estratégia de hash), deploy usando o arquivo .htaccess e modificação do base-href para deploy em subdiretórios.


// -------- Possíveis Ocorrências ---------

# Aplicação "quebrou" ao atualizar para a versão do Angular 5.0.5
Nova versão, novos bugs. :)
Há uma issue (do Angular 5.0.5) sugerindo o downgrade da versão do RxJS para 5.5.2:
https://github.com/angular/angular/issues/20752
